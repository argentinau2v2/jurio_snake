<html lang="ko"><head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>스네이크 게임</title>
	<style>
		:root { --bg: #0f172a; --fg: #e2e8f0; --accent: #22c55e; --danger: #ef4444; }
		html, body { height: 100%; }
		body { margin: 0; display: grid; place-items: center; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif; }
		.container { display: grid; gap: 12px; justify-items: center; }
		canvas { background: #0b1021; border: 2px solid #1f2a44; image-rendering: pixelated; width: 1440px; height: 1440px; }
		.hud { display: flex; gap: 16px; align-items: center; justify-content: center; }
		.badge { padding: 16px 28px; font-size: 24px; border-radius: 12px; background: #111827; border: 1px solid #1f2937; font-weight: 700; }
		button { padding: 16px 28px; font-size: 24px; border-radius: 12px; border: 1px solid #1f2937; background: #111827; color: var(--fg); cursor: pointer; font-weight: 700; }
		button:hover { background: #0f172a; }
		kbd { background: #111827; border: 1px solid #1f2937; padding: 2px 6px; border-radius: 6px; }
		.footer { opacity: .7; font-size: 20px; }
	</style>
</head>
<body>
	<div class="container">
		<div class="hud">
			<div class="badge">점수: <span id="score">0</span></div>
			<div class="badge">최고점수: <span id="best">0</span></div>
			<div class="badge mode" style="display: none;">모드: <span id="mode">일반모드</span></div>
			<div class="badge" style="display: none;">최근 아이템: <span id="last-item">-</span></div>
			<button id="btn-restart">다시 시작</button>
			<button id="btn-pause">일시정지</button>
			<button id="btn-capture">캡처</button>
		</div>
		<canvas id="game" width="7680" height="7680"></canvas>
		<div class="footer">이동: 방향키 • 일시정지: <kbd>P</kbd> • 다시 시작: <kbd>R</kbd> • 캡처: <kbd>Win</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd></div>
	</div>

	<script>
	(function() {
		const canvas = document.getElementById('game');
		const ctx = canvas.getContext('2d');
		ctx.imageSmoothingEnabled = false;

		// 렌더 스케일(내부 해상도 2배)
		const LOGICAL_WIDTH = 480;
		const LOGICAL_HEIGHT = 480;
		const RENDER_SCALE = 16;
		// 캔버스 백버퍼 해상도 업스케일, 좌표계 스케일 적용
		canvas.width = LOGICAL_WIDTH * RENDER_SCALE;
		canvas.height = LOGICAL_HEIGHT * RENDER_SCALE;
		try { ctx.setTransform(RENDER_SCALE, 0, 0, RENDER_SCALE, 0, 0); } catch {}

		function drawImagePx(img, dx, dy, dw, dh) {
			const off = 14 / RENDER_SCALE; // shift by 14 device pixels
			ctx.drawImage(img, dx + off, dy + off, dw, dh);
		}

		// 캐릭터 이미지 후보 자동 생성 (character/1~12.{png})
		const CHARACTER_CANDIDATES = (() => {
			const names = [];
			const exts = ['png'];
			for (let i = 1; i <= 6; i++) {
				for (const ext of exts) names.push(`character/${i}.${ext}`);
			}
			return names;
		})();
		let loadedHeadImages = [];
		let headImage = null;

		// --- 개선 제안: 게임 모드 관리 통합 ---
		const GAME_MODES = {
			NORMAL: { name: '일반모드', code: 'dlfqks', path: 'game/1', head: 1, tailColor: '#ffffff' },
			BUSINESS: { name: '출장맨모드', code: 'cnfwkdaos', path: 'game/2', head: 2, tailColor: '#db7f04' },
			WIZZRO: { name: '위즐로모드', code: 'dnlwmffh', path: 'game/3', head: 3, tailColor: '#ffff00' },
			CLARK: { name: '클라크모드', code: 'zmffkzm', path: 'game/4', head: 4, tailColor: '#9ca3af' },
			NOPD: { name: '노피디모드', code: 'shvlel', path: 'game/6', head: 6, tailColor: '#7CFC00' },
			ISORB: { name: '이솝모드', code: 'dlthq', path: 'game/5', head: 5, tailColor: '#228fe3' },
		};
		let currentMode = GAME_MODES.NORMAL;

		// 기존 is-모드 변수들을 currentMode를 통해 확인하도록 변경
		const isBusinessTripMode = () => currentMode === GAME_MODES.BUSINESS;
		const isClarkMode = () => currentMode === GAME_MODES.CLARK;
		const isNopdMode = () => currentMode === GAME_MODES.NOPD;
		const isWizzroMode = () => currentMode === GAME_MODES.WIZZRO;
		const isIsorbMode = () => currentMode === GAME_MODES.ISORB;
		// --- 개선 제안 끝 ---

		let wizzroSnakeName = null; // 위즐로모드에서 스네이크 이름(숫자)
		let wizzroFoods = []; // 위즐로모드: 동시 노출 음식 2개 [{x,y,img,index}]

		// SECRET_CODE 관련 상수는 GAME_MODES 객체로 통합됨
		// const SECRET_CODE = 'cnfwkdaos';
		// const SECRET_CODE_CLARK = 'zmffkzm';
		// const SECRET_CODE_NOPD = 'shvlel';
		// const SECRET_CODE_WIZZRO = 'dnlwmffh';
		// const SECRET_CODE_NORMAL = 'dlfqks';
		let secretBuffer = '';

		function preloadHeadImages() {
			const promises = CHARACTER_CANDIDATES.map(src => new Promise(resolve => {
				const img = new Image();
				img.onload = () => resolve({ ok: true, src, img });
				img.onerror = () => resolve({ ok: false, src });
				img.src = src;
			}));
			return Promise.all(promises).then(results => {
				loadedHeadImages = results.filter(r => r.ok).map(r => r.img);
				// 처음 로드 시에는 아무 것도 선택하지 않음. init()에서 강제 설정
			});
		}

		// 먹이 이미지 프리로드 및 순서 제어 (모드별 경로)
		const FOOD_EXTS = ['png'];
		let loadedFoodImages = []; // 순서대로 저장된 이미지 배열
		let foodImageIndex = 0; // 현재 사용할 이미지 인덱스
		let foodImage = null; // 현재 화면의 먹이 이미지
		let currentFoodSrc = null; // 단일 음식 모드에서 현재 음식의 src
		// 노피디모드: 동시 노출 음식 16개
		let nopdFoods = []; // [{x,y,img,index}]
		// 폭탄 아이템 (출장맨모드 전용)
		const BOMB_SRCS = ['game/2/17.png', 'game/2/18.png', 'game/2/19.png'];
		let loadedBombImages = [];
		let bombImageByName = {}; // {'17': Image, '18': Image, '19': Image}
		let bombs = []; // [{x,y,img}]

		function preloadBombImages() {
			const ps = BOMB_SRCS.map(src => new Promise(resolve => {
				const img = new Image();
				img.onload = () => resolve({ ok: true, img, src });
				img.onerror = () => resolve({ ok: false, src });
				img.src = src;
			}));
			return Promise.all(ps).then(rs => {
				loadedBombImages = rs.filter(r => r.ok).map(r => r.img);
				bombImageByName = {};
				for (const r of rs) {
					if (r.ok) {
						if (r.src.endsWith('/17.png')) bombImageByName['17'] = r.img;
						if (r.src.endsWith('/18.png')) bombImageByName['18'] = r.img;
						if (r.src.endsWith('/19.png')) bombImageByName['19'] = r.img;
					}
				}
			});
		}

		function getFoodBasePath() {
			return currentMode.path;
		}

		/**
		 * 현재 게임 모드에 맞는 경로에서 음식 이미지를 비동기적으로 불러옵니다.
		 * 1.png, 1.jpg 등 다양한 확장자를 시도하여 먼저 로드되는 이미지를 사용합니다.
		 * 모든 이미지 로딩이 완료되면 `loadedFoodImages` 배열을 채웁니다.
		 */
		function preloadFoodImages() {
			// 모드가 변경될 때를 대비해, 이전에 로드된 이미지 목록을 초기화합니다.
			loadedFoodImages = []; // 모드 변경 시 이미지 배열을 초기화하여 다른 모드의 이미지가 남지 않도록 합니다.
			// 현재 모드에 해당하는 이미지 폴더 경로를 가져옵니다. (예: 'game/1')
			const FOOD_BASE_PATH = getFoodBasePath();
			// 각 파일 인덱스(1~1000)에 대한 이미지 로딩 작업을 Promise로 관리하는 배열입니다.
			const perIndexPromises = [];

			let indexStart = 1;
			let indexEnd = 80;
			if (currentMode === GAME_MODES.BUSINESS) {
				indexStart = 17;
				indexEnd = 37;
			} else if (currentMode === GAME_MODES.CLARK) {
				indexStart = 52;
				indexEnd = 64;
			} else if (currentMode === GAME_MODES.NOPD) {
				indexStart = 1;
				indexEnd = 16;
			} else if (currentMode === GAME_MODES.WIZZRO) {
				indexStart = 81;
				indexEnd = 124;
			} else if (currentMode === GAME_MODES.ISORB) {
				indexStart = 65;
				indexEnd = 80;
			}

			// 1부터 125까지의 숫자 파일명을 가진 이미지를 찾습니다.
			for (let i = indexStart; i <= indexEnd; i++) {
				// 각 숫자마다 여러 이미지 확장자(png, jpg 등)를 시도할 목록을 생성합니다.
				const tryList = FOOD_EXTS.map(ext => `${FOOD_BASE_PATH}/${i}.${ext}`);
				// 각 인덱스(i)에 대한 로딩 작업을 하나의 Promise로 묶습니다.
				perIndexPromises.push(new Promise(resolveIndex => {
					let resolved = false; // 해당 인덱스에서 이미지를 성공적으로 로드했는지 여부
					let remaining = tryList.length; // 시도해야 할 남은 확장자 개수

					// 가능한 모든 확장자에 대해 이미지 로드를 시도합니다.
					for (const src of tryList) {
						const img = new Image();
						// 이미지 로딩 성공 시
						img.onload = () => {
							if (!resolved) { // 아직 해당 인덱스의 이미지가 로드되지 않았다면
								resolved = true;
								resolveIndex({ idx: i, img, src }); // Promise를 성공으로 처리하고 결과(이미지 정보)를 반환합니다.
							}
						};
						// 이미지 로딩 실패 시
						img.onerror = () => {
							remaining--;
							if (!resolved && remaining === 0) resolveIndex(null);
							// 모든 확장자를 시도했는데도 로딩에 실패했다면
							if (!resolved && remaining === 0) resolveIndex(null); // Promise를 null로 처리합니다.
						};
						img.src = src; // 이미지 로드를 시작합니다.
					}
				}));
			}
			// 모든 인덱스(1~1000)에 대한 이미지 로딩 작업이 끝날 때까지 기다립니다.
			return Promise.all(perIndexPromises).then(results => {
				// 로딩에 성공한 이미지들만 필터링하고, 파일 숫자 순서대로 정렬하여 `loadedFoodImages`에 저장합니다.
				loadedFoodImages = results.filter(Boolean).sort((a, b) => a.idx - b.idx);
				// 게임 시작 시 표시될 초기 음식 이미지를 설정합니다. (이후 spawnFood에서 다시 설정될 수 있음)
				if (loadedFoodImages.length > 0) { // 로드된 이미지가 하나라도 있다면
                    if (isNopdMode()) { // 노피디모드인 경우
                        foodImageIndex = 0; // 첫 번째 이미지부터 순서대로 사용
                    } else { // 그 외 모드인 경우
                        foodImageIndex = Math.floor(Math.random() * loadedFoodImages.length) + 1; // 랜덤 이미지 선택
                    }
					// 현재 모드에 맞는 규칙에 따라 초기 음식 이미지를 `foodImage` 변수에 할당합니다.
					foodImage = (isBusinessTripMode() ? chooseBusinessFoodImage() : loadedFoodImages[foodImageIndex]?.img) || null;
				} else { // 로드된 이미지가 없다면
					foodImageIndex = 0;
					foodImage = null;
				}
			});
		}

		function chooseBusinessFoodImage(returnBoth=false) {
			// 출장맨모드에서는 폭탄에 쓰이는 17/18/19 이미지를 제외
			const candidates = loadedFoodImages.filter(r => {
				const s = r.src || '';
				return !(s.endsWith('/17.png') || s.endsWith('/18.png') || s.endsWith('/19.png'));
			});
			if (candidates.length === 0) return returnBoth ? null : null;
			const pick = candidates[Math.floor(Math.random() * candidates.length)];
			return returnBoth ? { img: pick.img, src: pick.src } : (pick.img || null);
		}

		// 노피디모드 전용: 1.png ~ 16.png를 순서대로 사용
		let nopdFoodIndex = 0;
		function chooseNopdFoodImage(increment=false) {
			const candidates = loadedFoodImages
				.filter(r => /\/(?:[1-9]|1[0-6])\.png$/.test(r.src || ''))
				.sort((a,b)=>{
					const getNum = s => {
						const m = (s||'').match(/\/([0-9]+)\.png$/); return m? parseInt(m[1],10):0;
					};
					return getNum(a.src)-getNum(b.src);
				});
			if (candidates.length === 0) return null;
			if (increment) nopdFoodIndex = (nopdFoodIndex + 1) % candidates.length;
			const pick = candidates[nopdFoodIndex % candidates.length];
			return pick.img || null;
		}

		// 그리드 설정
		const CELL_SIZE = 24; // 타일 크기(px)
		const COLS = Math.floor(LOGICAL_WIDTH / CELL_SIZE);
		const ROWS = Math.floor(LOGICAL_HEIGHT / CELL_SIZE);
		const BASE_TICK_MS = 130; // 초기 이동 주기(ms)

		// 게임 상태
		let snake; // 배열: 머리 먼저, 각 원소는 {x, y}
		let direction; // {x, y}
		let nextDirection; // 입력 버퍼
		let food; // {x, y}
		let score = 0;
		let eatenFoodCount = 0; // 이솝모드용 먹은 아이템 개수
		let best = Number(localStorage.getItem('snake_best') || 0);
		let tickMs = BASE_TICK_MS; // 이동 주기(ms)
		let lastTick = 0;
		let isPaused = false;
		let isGameOver = false;
		let overlayMessage = null; // 오버레이에 표시할 특정 메시지

		const scoreEl = document.getElementById('score');
		const bestEl = document.getElementById('best');
		const modeEl = document.getElementById('mode');
		const lastItemEl = document.getElementById('last-item');
		bestEl.textContent = String(best);

		function init() {
			overlayMessage = null; // 게임 시작 시 오버레이 메시지 초기화
			snake = [
				{ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) }
			];
			direction = { x: 1, y: 0 };
			nextDirection = { x: 1, y: 0 };
			
			const desiredIndex = currentMode.head;
			// loadedHeadImages 배열에서는 로드된 순서이므로 직접 경로로 로드
			const desiredImg = new Image();
			desiredImg.onload = () => { headImage = desiredImg; };
			desiredImg.onerror = () => { headImage = null; };
			desiredImg.src = `character/${desiredIndex}.png`;
			// 음식 초기화
			if (isNopdMode()) {
				nopdInitFoods();
			} else if (isWizzroMode()) {
				wizzroInitFoods();
			} else {
				spawnFood();
			}
			score = 0;
			eatenFoodCount = 0;
			scoreEl.textContent = '0';
			tickMs = BASE_TICK_MS; // 속도 초기화
			isPaused = false;
			isGameOver = false;
			lastTick = 0;
			modeEl.textContent = currentMode.name;
			bombs = [];
			if (isBusinessTripMode()) rebalanceBombs();
			wizzroSnakeName = null; // 위즐로모드 스네이크 이름 초기화
			lastItemEl.textContent = '-'; // 초기화 시 빈 값으로 설정
		}

		function getFoodImageByIndex(idx) {
			// loadedFoodImages: [{idx,img,src}]
			for (const r of loadedFoodImages) {
				if ((r.src || '').endsWith(`/${idx}.png`)) return r.img;
			}
			return null;
		}

		function wizzroRandomEmptyCell() {
			for (let tries = 0; tries < 2000; tries++) {
				const x = Math.floor(Math.random() * COLS);
				const y = Math.floor(Math.random() * ROWS);
				const occupied = (
					(snake && snake.some(p => p.x === x && p.y === y)) ||
					(wizzroFoods && wizzroFoods.some(f => f.x === x && f.y === y)) ||
					(bombs && bombs.some(b => b.x === x && b.y === y))
				);
				if (!occupied) return { x, y };
			}
			return null;
		}

		function wizzroInitFoods() {
			wizzroFoods = [];
			// 2개 아이템을 선택하되, 번호 합이 홀수가 되도록 (game/3 폴더만)
			const candidates = loadedFoodImages.filter(r => {
				const src = r.src || '';
				return /game\/3\/[0-9]+\.(png)$/.test(src);
			});
			if (candidates.length === 0) return;
			
			// 첫 번째 아이템 랜덤 선택
			const firstPick = candidates[Math.floor(Math.random() * candidates.length)];
			const firstIdx = parseInt((firstPick.src || '').match(/\/([0-9]+)\.png$/)[1], 10);
			const firstPos = wizzroRandomEmptyCell();
			if (!firstPos) return;
			wizzroFoods.push({ x: firstPos.x, y: firstPos.y, img: firstPick.img, index: firstIdx });
			
			// 두 번째 아이템: 첫 번째와 합이 홀수가 되는 번호 선택
			const validCandidates = candidates.filter(r => {
				const idx = parseInt((r.src || '').match(/\/([0-9]+)\.png$/)[1], 10);
				return (firstIdx + idx) % 2 === 1; // 홀수
			});
			
			if (validCandidates.length > 0) {
				const secondPick = validCandidates[Math.floor(Math.random() * validCandidates.length)];
				const secondIdx = parseInt((secondPick.src || '').match(/\/([0-9]+)\.png$/)[1], 10);
				const secondPos = wizzroRandomEmptyCell();
				if (secondPos) {
					wizzroFoods.push({ x: secondPos.x, y: secondPos.y, img: secondPick.img, index: secondIdx });
				}
			}
		}

		function nopdRandomEmptyCell() {
			for (let tries = 0; tries < 2000; tries++) {
				const x = Math.floor(Math.random() * COLS);
				const y = Math.floor(Math.random() * ROWS);
				const occupied = (
					(snake && snake.some(p => p.x === x && p.y === y)) ||
					(nopdFoods && nopdFoods.some(f => f.x === x && f.y === y)) ||
					(bombs && bombs.some(b => b.x === x && b.y === y))
				);
				if (!occupied) return { x, y };
			}
			return null;
		}

		function nopdInitFoods() {
			nopdFoods = [];
			for (let i = 1; i <= 16; i++) {
				const img = getFoodImageByIndex(i);
				const pos = nopdRandomEmptyCell();
				if (!pos) continue;
				nopdFoods.push({ x: pos.x, y: pos.y, img, index: i });
			}
		}

		function nopdRespawnFoodWithSameIndex(index) {
			const img = getFoodImageByIndex(index);
			const pos = nopdRandomEmptyCell();
			if (!pos) return null;
			return { x: pos.x, y: pos.y, img, index };
		}

		function spawnFood() {
			if (isNopdMode() || isWizzroMode()) return; // 노피디/위즐로모드는 단일 음식 스폰 사용하지 않음
			while (true) {
				const x = Math.floor(Math.random() * COLS);
				const y = Math.floor(Math.random() * ROWS);
				const onSnake = snake && snake.some(p => p.x === x && p.y === y);
				const onBomb = bombs && bombs.some(b => b.x === x && b.y === y);
				if (!onSnake && !onBomb) {
					food = { x, y };
					// 모드별 먹이 이미지 선택: 일반=랜덤, 출장맨=제외랜덤, 클라크=랜덤, 노피디=순서, 위즐로=랜덤(game/3)
					if (loadedFoodImages.length > 0) {
						if (isBusinessTripMode()) {
							const pick = chooseBusinessFoodImage(true);
							foodImage = pick ? pick.img : null;
							currentFoodSrc = pick ? pick.src : null;
						} else if (isClarkMode()) {
							const any = loadedFoodImages[Math.floor(Math.random() * loadedFoodImages.length)];
							foodImage = any ? any.img : null;
							currentFoodSrc = any ? any.src : null;
						} else if (isWizzroMode()) {
							const any = loadedFoodImages[Math.floor(Math.random() * loadedFoodImages.length)];
							foodImage = any ? any.img : null;
							currentFoodSrc = any ? any.src : null;
						} else if (isNopdMode()) {
							foodImage = chooseNopdFoodImage(false);
							currentFoodSrc = null;
						} else {
							const any = loadedFoodImages[Math.floor(Math.random() * loadedFoodImages.length)];
							foodImage = any ? any.img : null;
							currentFoodSrc = any ? any.src : null;
						}
					} else {
						foodImage = null;
						currentFoodSrc = null;
					}
					break;
				}
			}
		}

		function getDesiredBombCount() {
			if (!isBusinessTripMode()) return 0;
			if (score >= 300) return 3;
			if (score >= 200) return 2;
			if (score >= 100) return 1;
			return 0;
		}

		function placeRandomBomb(imgOverride) {
			if (loadedBombImages.length === 0) return null;
			for (let tries = 0; tries < 2000; tries++) {
				const x = Math.floor(Math.random() * COLS);
				const y = Math.floor(Math.random() * ROWS);
				const occupied = (
					(snake && snake.some(p => p.x === x && p.y === y)) ||
					(food && food.x === x && food.y === y) ||
					(bombs && bombs.some(b => b.x === x && b.y === y))
				);
				if (!occupied) {
					const img = imgOverride || loadedBombImages[Math.floor(Math.random() * loadedBombImages.length)];
					return { x, y, img };
				}
			}
			return null;
		}

		function rebalanceBombs() {
			const need = getDesiredBombCount();
			if (bombs.length > need) {
				bombs = bombs.slice(0, need);
			} else {
				while (bombs.length < need) {
					// 폭탄 추가 순서에 따른 고정 이미지
					let img = null;
					if (bombs.length === 0 && bombImageByName['19']) img = bombImageByName['19'];
					else if (bombs.length === 1 && bombImageByName['18']) img = bombImageByName['18'];
					else if (bombs.length === 2 && bombImageByName['17']) img = bombImageByName['17'];
					const b = placeRandomBomb(img);
					if (!b) break;
					bombs.push(b);
				}
			}
		}

		function setDirection(nx, ny) {
			// 180도 반전 금지
			if (nx === -direction.x && ny === -direction.y) return;
			nextDirection = { x: nx, y: ny };
		}

		function update(dt) {
			if (isPaused || isGameOver) return;
			if (dt - lastTick < tickMs) return;
			lastTick = dt;

			// 방향 업데이트(한 틱에 한 번 적용)
			direction = nextDirection;

			// 머리 이동
			const head = snake[0];
			let newHead = { x: head.x + direction.x, y: head.y + direction.y };

			// 경계 처리: 이솝모드에서 벽이 활성화된 경우와 그 외 경우를 분리합니다.
			if (isIsorbMode() && (eatenFoodCount + 2) % 2 !== 0) { // 이솝모드이고, 벽이 활성화된 상태일 때
				// 이솝모드 벽 활성화 상태: 벽에 부딪히면 게임 오버
				if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) {
					gameOver();
					return;
				}
			} else { // 그 외 모든 경우 (벽이 없거나, 다른 모드)
				// 기본(토로이드): 반대편으로 연결
				newHead.x = (newHead.x + COLS) % COLS;
				newHead.y = (newHead.y + ROWS) % ROWS;
			}

			// 자기 몸 충돌 체크
			const hitBody = snake.some((seg, i) => i !== 0 && seg.x === newHead.x && seg.y === newHead.y);
			if (hitBody) {
				gameOver();
				return;
			}

			// 폭탄 충돌 체크 (머리)
			if (bombs && bombs.some(b => b.x === newHead.x && b.y === newHead.y)) {
				gameOver();
				return;
			}

			// 새 머리 추가
			snake.unshift(newHead);

			// 먹이 체크
			if (!isNopdMode() && !isWizzroMode() && newHead.x === food.x && newHead.y === food.y) {
				eatenFoodCount++; // 먹은 아이템 개수 증가
				// 점수: 일반모드 +5, 기본 +10, 출장맨모드에서 28.png +50
				let addScore = 10; // 기본 점수
				if (currentMode === GAME_MODES.NORMAL) addScore = 5;
				if (isClarkMode()) addScore = 15; // 클라크모드 점수
				if (isBusinessTripMode() && currentFoodSrc && (currentFoodSrc.endsWith('28.png'))) addScore = 50;
                // console.log('currentFoodSrc : ' + currentFoodSrc);
				score += addScore;
				scoreEl.textContent = String(score);
				if (score > best) {
					best = score;
					bestEl.textContent = String(best);
					localStorage.setItem('snake_best', String(best));
				}
				// 가속(선택) - 클라크모드는 일반보다 1.5배 빠르게 가속 (사용자 수정 가능)
				{
					const normalStep = 2;
					const step = isClarkMode() ? Math.max(1, Math.round(normalStep * 4)) : normalStep;
					tickMs = Math.max(60, tickMs - step);
				}
				// 출장맨모드: 다음 먹이 이미지를 순서대로 사용하도록 인덱스 증가
				if (isBusinessTripMode() && loadedFoodImages.length > 0) {
					foodImageIndex = (foodImageIndex + 1) % loadedFoodImages.length;
				}
				// 노피디모드: 다음 음식 이미지를 순서대로 사용
				if (isNopdMode()) {
					chooseNopdFoodImage(true);
				}
				// 점수에 따라 폭탄 수 재조정
				if (isBusinessTripMode()) rebalanceBombs();
				spawnFood();
				// 최근 아이템 갱신
				if (currentFoodSrc) lastItemEl.textContent = currentFoodSrc.split('/').pop();
			} else {
				if (isWizzroMode()) {
					// 위즐로모드: 2개 음식 중 충돌 확인
					const hitIdx = wizzroFoods.findIndex(f => f.x === newHead.x && f.y === newHead.y);
					if (hitIdx !== -1) {
						const hitFood = wizzroFoods[hitIdx];
						if (wizzroSnakeName === null) {
							// 첫 번째 아이템: 스네이크 이름 설정
							wizzroSnakeName = hitFood.index;
							score += 10;
							scoreEl.textContent = String(score);
							if (score > best) {
								best = score;
								bestEl.textContent = String(best);
								localStorage.setItem('snake_best', String(best));
							}
							// 모든 아이템 제거 후 새로 2개 생성
							wizzroFoods = [];
							wizzroInitFoods();
							lastItemEl.textContent = `${hitFood.index}.png`;
							return; // 꼬리 제거 없이 유지(성장)
						} else {
							// 두 번째 이후: 짝수/홀수 체크
							const sum = wizzroSnakeName + hitFood.index;
							if (sum % 2 === 0) {
								// 짝수: 계속 진행, 모든 아이템 제거 후 새로 2개 생성
								score += 10;
								scoreEl.textContent = String(score);
								if (score > best) {
									best = score;
									bestEl.textContent = String(best);
									localStorage.setItem('snake_best', String(best));
								}
								wizzroFoods = [];
								wizzroInitFoods();
								lastItemEl.textContent = `${hitFood.index}.png`;
								return; // 꼬리 제거 없이 유지(성장)
							} else {
								// 홀수: 게임 오버
								gameOver();
								return;
							}
						}
					}
				}
				if (isNopdMode()) {
					// NOPD 모드: 여러 음식 중 충돌 확인
					const hitIdx = nopdFoods.findIndex(f => f.x === newHead.x && f.y === newHead.y);
					if (hitIdx !== -1) {
						const tailCount = Math.max(0, snake.length - 2);
						const crystal = ((tailCount + 16) % 16) + 1;
						const hitFood = nopdFoods[hitIdx];
						if (hitFood.index === crystal) {
                            // console.log('snake.length : ' + snake.length);
                            // console.log('tailCount : ' + tailCount);
                            // console.log('hitFood.index : ' + hitFood.index);
                            // console.log('crystal : ' + crystal);
							// 정답: 점수/가속 처리, 아이템 교체, 꼬리 증가(=pop 생략)
							score += 10;
							scoreEl.textContent = String(score);
							if (score > best) {
								best = score;
								bestEl.textContent = String(best);
								localStorage.setItem('snake_best', String(best));
							}
							{
								const normalStep = 2;
								const step = isClarkMode() ? Math.max(1, Math.round(normalStep * 2)) : normalStep;
								tickMs = Math.max(60, tickMs - step);
							}
							// 해당 인덱스 아이템 재배치
							const replaced = nopdRespawnFoodWithSameIndex(hitFood.index);
							if (replaced) nopdFoods[hitIdx] = replaced;
							lastItemEl.textContent = `${hitFood.index}.png`;
							return; // 꼬리 제거 없이 유지(성장)
						} else {
                            // console.log('snake.length : ' + snake.length);
                            // console.log('tailCount : ' + tailCount);
                            // console.log('hitFood.index : ' + hitFood.index);
                            // console.log('crystal : ' + crystal);
							// 오답: 게임 오버
							gameOver();
							return;
						}
					}
				}
				// 꼬리 제거
				snake.pop();
			}
		}

		function drawCell(x, y, color) {
			ctx.fillStyle = color;
			const off = 1; // shift by 2 device pixels
			ctx.fillRect(x * CELL_SIZE + off, y * CELL_SIZE + off, CELL_SIZE - 1, CELL_SIZE - 1);
		}

		function drawGrid() {
			ctx.strokeStyle = 'rgba(255,255,255,0.05)';
			ctx.lineWidth = 1;
			for (let x = 0; x <= COLS; x++) {
				ctx.beginPath();
				ctx.moveTo(x * CELL_SIZE + 0.5, 0);
				ctx.lineTo(x * CELL_SIZE + 0.5, LOGICAL_HEIGHT);
				ctx.stroke();
			}
			for (let y = 0; y <= ROWS; y++) {
				ctx.beginPath();
				ctx.moveTo(0, y * CELL_SIZE + 0.5);
				ctx.lineTo(LOGICAL_WIDTH, y * CELL_SIZE + 0.5);
				ctx.stroke();
			}
		}

		function render() {
			ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
			drawGrid();

			// 이솝모드 벽 렌더링
			if (isIsorbMode() && (eatenFoodCount + 2) % 2 !== 0) {
				ctx.strokeStyle = '#ffffff';
				ctx.lineWidth = 4; // 4px
				ctx.strokeRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
			}

			// 먹이 렌더링
			if (isNopdMode()) {
				for (const f of nopdFoods) {
					if (f.img) {
						drawImagePx(f.img, f.x * CELL_SIZE, f.y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
					} else {
						drawCell(f.x, f.y, '#f59e0b');
					}
				}
			} else if (isWizzroMode()) {
				for (const f of wizzroFoods) {
					if (f.img) {
						drawImagePx(f.img, f.x * CELL_SIZE, f.y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
					} else {
						drawCell(f.x, f.y, '#f59e0b');
					}
				}
			} else {
				if (foodImage) {
					drawImagePx(foodImage, food.x * CELL_SIZE, food.y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
				} else {
					drawCell(food.x, food.y, '#f59e0b');
				}
			}
			// 폭탄
			if (bombs && bombs.length) {
				for (const b of bombs) {
					if (b.img) {
						drawImagePx(b.img, b.x * CELL_SIZE, b.y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
					} else {
						drawCell(b.x, b.y, '#ef4444');
					}
				}
			}
			// 스네이크
			snake.forEach((seg, idx) => {
				if (idx === 0 && headImage) {
					drawImagePx(headImage, seg.x * CELL_SIZE, seg.y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
				} else {
					const tailColor = currentMode.tailColor;
					drawCell(seg.x, seg.y, tailColor);
				}
			});

			if (overlayMessage) drawOverlay(overlayMessage);
			else if (isPaused) drawOverlay('일시정지');
			if (isGameOver) drawOverlayForGameOver();
		}

		function drawOverlay(text) {
			ctx.fillStyle = 'rgba(0,0,0,0.5)';
			ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
			ctx.fillStyle = '#e2e8f0';
			ctx.font = 'bold 28px system-ui, Apple SD Gothic Neo, Malgun Gothic, sans-serif';
			ctx.textAlign = 'center';
			ctx.fillText(text, LOGICAL_WIDTH / 2, LOGICAL_HEIGHT / 2);
		}

		function drawOverlayForGameOver() {
			ctx.fillStyle = 'rgba(0,0,0,0.5)';
			ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
			ctx.fillStyle = '#e2e8f0';
			ctx.textAlign = 'center';
			if (currentMode.name === '일반') {
				ctx.font = 'bold 28px system-ui, Apple SD Gothic Neo, Malgun Gothic, sans-serif';
				ctx.fillText('점수 : ' + score, LOGICAL_WIDTH / 2, LOGICAL_HEIGHT / 2);
			} else {
				ctx.font = 'bold 14px system-ui, Apple SD Gothic Neo, Malgun Gothic, sans-serif';
				ctx.fillText(currentMode.name, LOGICAL_WIDTH / 2, LOGICAL_HEIGHT / 2 - 20);
				ctx.font = 'bold 28px system-ui, Apple SD Gothic Neo, Malgun Gothic, sans-serif';
				ctx.fillText('점수 : ' + score, LOGICAL_WIDTH / 2, LOGICAL_HEIGHT / 2 + 20);
			}
		}

		function gameOver() {
			isGameOver = true;
		}

		function gameLoop(dt) {
			update(dt);
			render();
			requestAnimationFrame(gameLoop);
		}

		function togglePause() {
			if (isGameOver) return;
			isPaused = !isPaused;
		}

		function captureCanvas() {
			// 현재 캔버스의 내용을 Data URL (PNG 형식)로 변환합니다.
			const dataUrl = canvas.toDataURL('image/png');

			// 다운로드를 위한 임시 <a> 태그를 생성합니다.
			const link = document.createElement('a');
			link.href = dataUrl;
			link.download = `snake-capture-${Date.now()}.png`; // 파일명 설정
			
			// 링크를 클릭하여 다운로드를 시작하고, 이후 링크를 제거합니다.
			link.click();
		}

		// 입력 처리
		document.addEventListener('keydown', (e) => {
			const k = e.key.toLowerCase();
			if (k === 'arrowup') setDirection(0, -1);
			else if (k === 'arrowdown') setDirection(0, 1);
			else if (k === 'arrowleft') setDirection(-1, 0);
			else if (k === 'arrowright') setDirection(1, 0);
			else if (k === 'p') togglePause();
			else if (k === 'r') { init(); }
			// 일시정지 상태에서 비밀코드 입력 처리
			if (isPaused && !isGameOver) {
				if (/^[a-z]$/.test(k)) {
					secretBuffer += k;					
					let matched = false;
					for (const modeKey in GAME_MODES) {
						const mode = GAME_MODES[modeKey];
						if (secretBuffer === mode.code) {
							currentMode = mode;
							matched = true;
							secretBuffer = '';
							nopdFoodIndex = 0; // NOPD 모드 인덱스 초기화

							// 모드와 최근 아이템 표시를 활성화합니다.
							const modeBadge = document.querySelector('.badge.mode');
							if (modeBadge) modeBadge.style.display = '';

							// 모드 변경 메시지를 표시하고 0.5초 대기합니다.
							overlayMessage = `${currentMode.name}로 변경합니다`;
							setTimeout(() => {
								// 필요한 이미지들을 다시 불러옵니다.
								const promises = [preloadFoodImages()];
								if (isBusinessTripMode()) {
									promises.push(preloadBombImages());
								}
								// 이미지 로딩이 완료되면 게임을 초기화합니다.
								// init()이 호출되면 overlayMessage는 null로 초기화됩니다.
								Promise.all(promises).then(() => init());
							}, 500); // 0.5초 (500ms)
							break;
						}
					}

					if (!matched && !Object.values(GAME_MODES).some(m => m.code.startsWith(secretBuffer))) {
						secretBuffer = Object.values(GAME_MODES).some(m => m.code.startsWith(k)) ? k : '';
					}
				}
			}
		});

		document.getElementById('btn-restart').addEventListener('click', () => init());
		document.getElementById('btn-pause').addEventListener('click', () => togglePause());
		document.getElementById('btn-capture').addEventListener('click', captureCanvas);

		// --- 시작 로직 수정 ---
		// 1. 모든 이미지를 비동기적으로 불러옵니다.
		Promise.all([
			preloadHeadImages(),
			preloadFoodImages(),
			preloadBombImages()
		]).then(() => {
			// 2. 로딩이 완료되면 콘솔에 로드된 이미지 목록을 출력합니다.
			// console.log("--- 이미지 로딩 완료 ---");
			// console.log("캐릭터 이미지:", loadedHeadImages);
			// console.log("음식 이미지:", loadedFoodImages);
			// console.log("폭탄 이미지:", loadedBombImages);
			// console.log("----------------------");

			// 3. 10초 대기 후 게임을 시작합니다.
			drawOverlay('Now Loading...');
			setTimeout(() => {
				init();
				requestAnimationFrame(gameLoop);
			}, 1000); // 1초 (1000ms)
		});
	})();
	</script>



</body></html>
